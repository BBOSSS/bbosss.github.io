<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>死锁的预防、检测、避免、解除</title>
      <link href="/2018/09/02/%E6%AD%BB%E9%94%81/"/>
      <url>/2018/09/02/%E6%AD%BB%E9%94%81/</url>
      <content type="html"><![CDATA[<h3 id="造成死锁的原因"><a href="#造成死锁的原因" class="headerlink" title="造成死锁的原因"></a><strong>造成死锁的原因</strong></h3><p><strong>①互斥　②不可剥夺　③请求和保持　④形成环路</strong></p><h3 id="预防死锁：资源静态分配"><a href="#预防死锁：资源静态分配" class="headerlink" title="预防死锁：资源静态分配"></a><strong>预防死锁：资源静态分配</strong></h3><p>  资源静态分配法可以预防死锁的发生，因为它使 <strong>请求和保持条件</strong> 不成立。<br><a id="more"></a></p><h3 id="检测死锁：资源分配资源简化法"><a href="#检测死锁：资源分配资源简化法" class="headerlink" title="检测死锁：资源分配资源简化法"></a><strong>检测死锁：资源分配资源简化法</strong></h3><p>  <strong>方法步骤：</strong><br>  第一步：先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞的（“不阻塞”即：系统有足够的空闲资源分配给它）<br>  第二步：把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来。<br>  第三步：看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点。<br>  第四步：最后，所有的资源和进程都变成孤立的点。这样的图就叫做<strong>“可完全简化”</strong>。<br>  <strong>实例：</strong><br>  <img src="http://pe4fbo1qb.bkt.clouddn.com/zyfp1.png" alt=""><br>  ①先看R1资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，R1没有空闲的资源剩余。<br>  ②再看R2资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，R2还剩余一个空闲的资源没分配。<br>  ③看完资源，再来看进程，先看进程P2，它只申请一个R1资源，但此时R1资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。<br>  ④再看进程P1，它只申请一个R2资源，此时，系统还剩余一个R2资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示：<br>  <img src="http://pe4fbo1qb.bkt.clouddn.com/zyfp2.png" alt=""><br>  ⑤进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图：<br>  <img src="http://pe4fbo1qb.bkt.clouddn.com/zyfp3.png" alt=""></p><h3 id="避免死锁：银行家算法"><a href="#避免死锁：银行家算法" class="headerlink" title="避免死锁：银行家算法"></a><strong>避免死锁：银行家算法</strong></h3><p>在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p><ul><li><p><strong>数据定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;<span class="comment">// 系统中进程总数n和资源种类总数m</span></span><br><span class="line"><span class="keyword">int</span> Available[<span class="number">1</span>-m];<span class="comment">// 资源当前可用总量</span></span><br><span class="line"><span class="keyword">int</span> Max[<span class="number">1</span>-n][<span class="number">1</span>-m];<span class="comment">// 进程所需的最大资源</span></span><br><span class="line"><span class="keyword">int</span> Allocation[<span class="number">1</span>-n,<span class="number">1</span>-m];<span class="comment">// 当前给分配给每个进程的各种资源数量</span></span><br><span class="line"><span class="keyword">int</span> Need[<span class="number">1</span>-n,<span class="number">1</span>-m];<span class="comment">// 当前每个进程还需分配的各种资源数量</span></span><br></pre></td></tr></table></figure></li><li><p><strong>资源申请</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Request[<span class="number">1</span>-n][<span class="number">1</span>-m];<span class="comment">// 进程的申请向量</span></span><br><span class="line">(<span class="number">1</span>) 检查 <span class="keyword">if</span>(Request[i][j] &lt;= Need[i][j]) 进入步骤（<span class="number">2</span>），否则出错。</span><br><span class="line">(<span class="number">2</span>) 检查 <span class="keyword">if</span>(Request[i][j] &lt;= Available[j]) 进入步骤（<span class="number">3</span>），否则等待。</span><br><span class="line">(<span class="number">3</span>) 系统试探地把资源分给 Pi 并修改各项属性值（具体是否成立，则根据安全检查的结果）</span><br><span class="line">　　Available[j] = Available[j] — Request[i][j]</span><br><span class="line">　　Allocation[i][j] = Allocation[i][j] + Request[i][j]</span><br><span class="line">　　Need[i][j] = Need[i][j] — Request[i][j]</span><br><span class="line">(<span class="number">4</span>) 安全检查，若检查结果为安全，则（<span class="number">3</span>）中执行有效，否则分配作废，使该Pi进程进入等待。</span><br></pre></td></tr></table></figure></li><li><p><strong>安全性检查</strong><br>1) 从进程队列中找一个能满足下述条件的进程Pi<br>　　①、Finish[ i ]==false，表示资源未分配给Pi进程<br>　　②、Need[ i ][ j ]&lt;Free[ j ]，表示资源足够分配给Pi进程<br>2) 当Pi获得资源后，认为Pi完成，释放资源<br><strong>伪代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSafe</span><span class="params">(Available, Need, Allocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Free[m];<span class="comment">// 当前可用资源，初始化为Available</span></span><br><span class="line">    <span class="keyword">bool</span> Finish[n];<span class="comment">// 当前进程是否可完成，初始化为false</span></span><br><span class="line">    <span class="keyword">int</span> FinishCnt = <span class="number">0</span>;<span class="comment">// 记录可完成进程的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; n; cnt++) &#123;<span class="comment">// 检查的次数</span></span><br><span class="line">        Found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">// 找到未完成的进程</span></span><br><span class="line">            <span class="keyword">if</span>(Finish[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>( ; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">if</span>(Need[i][j] &gt; Free[j]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(j == m+<span class="number">1</span>) &#123;<span class="comment">// 如果每种资源都满足则该进程可完成</span></span><br><span class="line">                Finish[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= m; j++)<span class="comment">// 释放资源</span></span><br><span class="line">                    Free[j] += Allocation[i][j];</span><br><span class="line">                FinishCnt ++；<span class="comment">// 记录可完成进程的个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(FinishCnt &lt; n)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="解除死锁：剥夺资源法和撤销进程"><a href="#解除死锁：剥夺资源法和撤销进程" class="headerlink" title="解除死锁：剥夺资源法和撤销进程"></a><strong>解除死锁：剥夺资源法和撤销进程</strong></h3>]]></content>
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设置 socket 为非阻塞模式的三种方法</title>
      <link href="/2018/09/01/%E8%AE%BE%E7%BD%AE-socket-%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2018/09/01/%E8%AE%BE%E7%BD%AE-socket-%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="设置-socket-为非阻塞模式的三种方法"><a href="#设置-socket-为非阻塞模式的三种方法" class="headerlink" title="设置 socket 为非阻塞模式的三种方法"></a>设置 socket 为非阻塞模式的三种方法</h2><ul><li><strong>创建socket的时候，指定socket是异步的，在type的参数中设置SOCK_NONBLOCK标志即可。</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p><strong>使用fcntl函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, <span class="number">0</span>) | O_NONBLOCK);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用ioctl函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(sockfd, FIONBIO, <span class="number">1</span>);  <span class="comment">// 1:非阻塞 0:阻塞</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> socket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++正则表达式 regex</title>
      <link href="/2018/09/01/C++%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fregex/"/>
      <url>/2018/09/01/C++%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fregex/</url>
      <content type="html"><![CDATA[<h2 id="C-正则表达式应用"><a href="#C-正则表达式应用" class="headerlink" title="C++正则表达式应用"></a>C++正则表达式应用</h2><p>前篇博客学习了正则表达式的基本语法规则，在这里进行简单的应用例子。C++11添加了regex 头文件支持正则表达式，regex 也属于 std 名称空间，另外 boost 库也支持正则表达式。下面使用 regex 匹配整数形式和十六进制形式的 IP 地址，判断 IP 是否有效。<br><a id="more"></a><br><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> ip_int = <span class="string">"192.168.4.245"</span>;</span><br><span class="line"><span class="built_in">string</span> ip_hex = <span class="string">"C0.A8.04.f5"</span>;</span><br><span class="line"><span class="built_in">string</span> expression_int = <span class="string">"((2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?).)&#123;3&#125;(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)"</span>;</span><br><span class="line"><span class="built_in">string</span> expression_hex = <span class="string">"(([0-9A-Fa-f][0-9A-Fa-f]|[0-9A-Fa-f]?[0-9A-Fa-f]).)&#123;3&#125;([0-9A-Fa-f][0-9A-Fa-f]|[0-9A-Fa-f]?[0-9A-Fa-f])"</span>;</span><br><span class="line"><span class="function">regex <span class="title">regex_int</span><span class="params">(expression_int)</span></span>;</span><br><span class="line"><span class="function">regex <span class="title">regex_hex</span><span class="params">(expression_hex)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(regex_match(ip_int, regex_int))</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Is vaild int IP address."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Is invaild int IP address."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(regex_match(ip_hex, regex_hex)) </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Is vaild hex IP address."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Is invaild hex IP address."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is vaild int IP address.</span><br><span class="line">Is vaild hex IP address.</span><br></pre></td></tr></table></figure></p><p><strong>注意：regex_match 匹配整个字符串，只要全部匹配才返回 true，否在返回 false。部分匹配可使用 regex_search，用法和 regex_match 一样。另外还有 regex_replace 用于查找匹配到的字符并且替换。</strong></p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Regular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式基本语法规则</title>
      <link href="/2018/08/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/08/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="正则表达式基本语法规则"><a href="#正则表达式基本语法规则" class="headerlink" title="正则表达式基本语法规则"></a>正则表达式基本语法规则</h2><p><strong>原文：<a href="https://www.cnblogs.com/yunfeifei/p/4071467.html" target="_blank" rel="noopener">有shi以来最详细的正则表达式入门教程</a></strong></p><h3 id="正则表达式到底是什么东西？"><a href="#正则表达式到底是什么东西？" class="headerlink" title="正则表达式到底是什么东西？"></a>正则表达式到底是什么东西？</h3><p>　　正则表达式，又称正规表示法、常规表示法（英语：Regular Expression），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。　　<br>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。<a id="more"></a><br>　　你使用过Windows/Dos下用于文件查找的通配符(wildcard)，也就是*和?。如果你想查找某个目录下的所有的Word文档的话，你会搜索*.doc。在这里，*会被解释成任意的字符串。和通配符类似，正则表达式也是用来进行文本匹配的工具，只不过比起通配符，它能更精确地描述你的需求——当然，代价就是更复杂——比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串(像010-12345678或0321-7654321)。</p><h3 id="初识正则表达式"><a href="#初识正则表达式" class="headerlink" title="初识正则表达式"></a>初识正则表达式</h3><p>　　学习正则表达式的最好方法是从例子开始，理解例子之后再对例子进行修改，实验。下面给出了不少简单的例子，并对它们作了详细的说明。假设你在一篇英文文章里面查找hi，你可以使用正则表达式hi。这几乎是最简单的正则表达式了，它可以精确匹配这样的字符串：由两个字符组成，前一个字符是h,后一个是i。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。<br>　　不幸的是，很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b。<br>　　\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。<br>　　如果需要更精确的说法，\b匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)\w。<br>　　假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.*\bLucy\b。这里，.是另一个元字符，匹配除了换行符以外的任意字符。*同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定*前边的内容可以连续重复使用任意次以使整个表达式得到匹配。因此，.*连在一起就意味着任意数量的不包含换行的字符。现在\bhi\b.*\bLucy\b的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词。<br>　　换行符就是’\n’,ASCII编码为10(十六进制0x0A)的字符。<br>如果同时使用其它元字符，我们就能构造出功能更强大的正则表达式。比如下面这个例子：0\d\d-\d\d\d\d\d\d\d\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码。当然，这个例子只能匹配区号为3位的情形)。这里的\d是个新的元字符，匹配一位数字(0，或1，或2，或……)。-不是元字符，只匹配它本身——连字符(或者减号，或者中横线，或者随你怎么称呼它)。为了避免那么多烦人的重复，我们也可以这样写这个表达式：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。　　</p><h3 id="正则表达式基础"><a href="#正则表达式基础" class="headerlink" title="正则表达式基础"></a>正则表达式基础</h3><ul><li><strong>元字符</strong><br>现在你已经知道几个很有用的元字符了，如\b,.,*，还有\d.正则表达式里还有更多的元字符，比如\s匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。\w匹配字母或数字或下划线或汉字等。对中文/汉字的特殊处理是由.Net提供的正则表达式引擎支持的，其它环境下的具体情况请查看相关文档。<br>下面来看看更多的例子：<br>　　\ba\w*\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的\w。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)<br>　　\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\b\w{6}\b 匹配刚好6个字符的单词。 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。<br>　　这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入必须是5到12个数字，因此如     果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。</li></ul><table><thead><tr><th style="text-align:center">说明</th><th style="text-align:center">字符</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母或数字或下划线或汉字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任意的空白符</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串的开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串的结束</td></tr></tbody></table><ul><li><p><strong>字符转义</strong><br>如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\.   例如：asp\.net匹配asp.net，C:\\Windows匹配C:\Windows。</p></li><li><p><strong>重复次数</strong><br>你已经看过了前面的*,+,{2},{5,12}这几个匹配重复的方式了。下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)：</p></li></ul><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">重复零次或更多次</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">重复一次或更多次</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">重复零次或一次</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">重复n次</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">重复n次或更多次</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">重复n到m次</td></tr></tbody></table><p>　　下面是一些使用重复的例子：<br>　　Windows\d+匹配Windows后面跟1个或更多数字<br>　　^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)</p><ul><li><p><strong>字符类</strong><br>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？<br>　　很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。<br>下面是一个更复杂的表达式：(?0\d{2}[) -]?\d{8}。“(”和“)”也是元字符，后面的分组节里会提到，所以在这里需要使用转义。<br>　　这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p></li><li><p><strong>分支条件</strong><br>不幸的是，刚才那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。听不明白？没关系，看例子：<br>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。<br>(?0\d{2})?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。<br>　　\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分支条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分支的话，就不会去再管其它的条件了。。 </p></li><li><p><strong>分组</strong><br>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。<br>　　(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).<br>　　不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：<strong>((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</strong>。理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。</p></li><li><p><strong>反义</strong><br>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：</p></li></ul><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配任意不是空白符的字符</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配任意非数字的字符</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">匹配不是单词开头或结束的位置</td></tr><tr><td style="text-align:center">[^x]</td><td style="text-align:center">匹配除了x以外的任意字符</td></tr><tr><td style="text-align:center">[^abcd]</td><td style="text-align:center">匹配除了abcd这几个字母以外的任意字符</td></tr></tbody></table><p><a href="https://www.cnblogs.com/yunfeifei/p/4071467.html" target="_blank" rel="noopener"><strong>更多内容可查看原文</strong></a></p>]]></content>
      
      <categories>
          
          <category> Regular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大小端判断方法</title>
      <link href="/2018/08/26/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/26/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="大小端判断方法"><a href="#大小端判断方法" class="headerlink" title="大小端判断方法"></a>大小端判断方法</h2><p> <strong>小端字节序</strong><br>高序字节在高地址位，低序字节在低地址位<br><strong>大端字节序</strong><br>低序字节在高地址位，高序字节在低地址位<br><a id="more"></a></p><ul><li><p><strong>利用共用体几个不同的变量共同占用一段内存的性质输出第一个字节</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> UN</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.i = <span class="number">1</span>;<span class="comment">// 置低位为 1</span></span><br><span class="line">    <span class="keyword">return</span> un.c;<span class="comment">// 若为 1 则是小端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>利用指针类型强制转换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = *(<span class="keyword">char</span>*)&amp;i;<span class="comment">// 取 i 的地址 强制类型转换后解引用</span></span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">// 若为 1 则是小端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>new 与 malloc 的区别</title>
      <link href="/2018/08/26/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/08/26/new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="new-与-malloc-的区别"><a href="#new-与-malloc-的区别" class="headerlink" title="new 与 malloc 的区别"></a>new 与 malloc 的区别</h3><p><strong>前两篇博客分析了 malloc 和 new 的原理，这里再简单说明一下区别。</strong></p><ul><li>malloc 需要使用参数具体指出申请的内存大小，以字节为单位。而 new 不用指出大小，只需指明类型。<a id="more"></a></li><li>malloc 申请成功返回一个void* 指针，需要我们手动进行转换。而 new 返回的是具体类型的指针。</li><li>malloc 申请失败返回NULL。而 new 申请失败直接抛出异常。</li><li>new 一个类或者结构体的时候需要调用构造函数， 这说明 new 可以在申请的时候直接初始化。</li><li>malloc 申请数组的时候需要先计算内存的大小。而 new 只需指明元素个数。</li></ul><h3 id="free-与-delete"><a href="#free-与-delete" class="headerlink" title="free 与 delete"></a>free 与 delete</h3><ul><li>free 只需传入由 malloc 申请的内存地址，free 需要判断 指针是否为NULL。</li><li>delete 一个类的时候会调用析构函数，delete 不需要判断指针是否为NULL。</li><li>delete 和 free 后都需把指针置为NULL，防止野指针。</li><li>不可重复释放内存空间，但可以重复释放NULL，因为释放NULL什么也没发生。</li></ul>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>new &amp; delete 原理</title>
      <link href="/2018/08/26/new-delete/"/>
      <url>/2018/08/26/new-delete/</url>
      <content type="html"><![CDATA[<h2 id="new-amp-delete-原理"><a href="#new-amp-delete-原理" class="headerlink" title="new &amp; delete 原理"></a>new &amp; delete 原理</h2><h3 id="基本概念和用法"><a href="#基本概念和用法" class="headerlink" title="基本概念和用法"></a>基本概念和用法</h3><p><strong>malloc 和 free 是 C 的库函数，而 new 和 delete 是 C++ 的运算符，也是 C++ 的关键字。</strong><br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">// 未初始化值</span></span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);<span class="comment">// 初始化为 5</span></span><br><span class="line">    <span class="keyword">int</span> *c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];<span class="comment">// 开辟一个大小为100的整型数组空间</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">delete</span> a; <span class="comment">// delete会自动检测是否为NULL</span></span><br><span class="line">    a = <span class="literal">NULL</span>;<span class="comment">// delete之后不会自动置为NULL</span></span><br><span class="line">    <span class="keyword">delete</span> a;<span class="comment">// 注意不能对同个指针多次delete</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    b = <span class="literal">NULL</span>;<span class="comment">// delete之后要防止野指针</span></span><br><span class="line">    <span class="keyword">delete</span> [] c;<span class="comment">// 数组delete要加方括号[]</span></span><br><span class="line">    c = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-原理："><a href="#new-原理：" class="headerlink" title="new 原理："></a>new 原理：</h3><p><strong>new 是 C++ 使用 operator new 重载的运算符</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__<span class="function">CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">void</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _THROW_NCEE(_XSTD bad_alloc, );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>operator new 的实现是调用了malloc函数申请内存，而当申请失败也就是返回空指针时，判断  _callnewh(size) 返回值是否为0，若为0则抛出一个异常，非0则继续循环执行malloc。_callnewh的作用就是调用一个被称作new_handler的函数，作用类似与回调函数，在VS中我们可以使用_set_new_handler函数来设置自己的回调函数，该函数的参数须为 size_t size。</p><p><strong>new 的执行过程</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> -&gt; <span class="keyword">operator</span> <span class="keyword">new</span> -&gt; <span class="built_in">malloc</span></span><br></pre></td></tr></table></figure></p><p>new会调用malloc进行内存分配的操作。但他和malloc不用的是，他分配失败时会调用new_handler,而new_handler返回0的情况抛出异常，而malloc只会返回一个空指针。</p><p><strong>new T 类型</strong><br>（1）调用operator new(sizeof(T))，该函数的函数原型为void* operator new(size_t size)。<br>（2）调用operator new中的malloc(set_new_handle)，如果申请成功，返回；申请失败（可能原因是内存空间不足），采取应对措施set_new_handler，如果应对措施没有，抛出一个异常。<br>（3）调用一次该类型 T 的构造函数。</p><p><strong>new T[N] 类型数组</strong><br>（1）调用operator new[] (N*sizeof(T))，会在申请的空间的头部多给4个字节的空间，用来存放N。<br>（2）调用operator new函数<br>（3）调用malloc函数<br>（4）调用N次构造函数，构造出来N个对象。<br>（5）返回第一个对象所在的首地址，不是原空间的地址，而是原空间的地址向后偏移4个位置</p><h3 id="delete-原理："><a href="#delete-原理：" class="headerlink" title="delete 原理："></a>delete 原理：</h3><p><strong>delete 是 C++ 使用 operator delete 重载的运算符</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    RTCCALLBACK(_RTC_Free_hook, (p, <span class="number">0</span>));  </span><br><span class="line">    <span class="built_in">free</span>(p);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RTCCALLBACK默认是空的宏定义，所以这个函数默认情况下就是简单的调用 free 函数。<br>delete 简单数据类型默认只是调用 free 函数，delete 复杂数据类型先调用析构函数再调用 operator delete。</p><p><strong>delete T 类型</strong><br>（1）调用一次该类型 T 的析构函数。<br>（2）调用operator delete，释放空间地址。<br>（3）调用free函数。</p><p><strong>delete[] T 类型</strong><br>（1）取出 N（在空间的前四个字节中）。<br>（2）调用 N 次析构函数。<br>（3）调用 operator delete[] (p)。<br>（4）调用 operator delete。<br>（5）调用 free 函数。</p><p><strong>new [] 会先计算出申请元素的个数N，并把N记录在申请到的内存的前 4 个字节</strong><br><strong>delete [] 从该指针指向内存的前 4 个字节取出大小N，调用 free </strong></p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>malloc &amp; free 原理</title>
      <link href="/2018/08/26/malloc-free/"/>
      <url>/2018/08/26/malloc-free/</url>
      <content type="html"><![CDATA[<h2 id="malloc-和-free-的原理"><a href="#malloc-和-free-的原理" class="headerlink" title="malloc 和 free 的原理"></a>malloc 和 free 的原理</h2><h3 id="基本概念和用法"><a href="#基本概念和用法" class="headerlink" title="基本概念和用法"></a>基本概念和用法</h3><ul><li><strong>函数原型</strong><br><strong>void *malloc(long NumBytes)</strong>：该函数分配了NumBytes个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针 NULL。<br><strong>void free(void *FirstByte)</strong>： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。<a id="more"></a></li><li><p><strong>使用方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)<span class="comment">// 申请成功</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Memory allocated at: %x\n"</span>,p);</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 申请失败</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Not enough memory\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;<span class="comment">// 防止野指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注意事项</strong><br>①申请了内存空间后，必须检查是否分配成功。<br>②当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。<br>③这两个函数应该是配对。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）<br>④malloc() 返回的是 void* 指针，需要转为特定类型的指针。</p></li></ul><h3 id="malloc-原理"><a href="#malloc-原理" class="headerlink" title="malloc 原理"></a>malloc 原理</h3><p><strong>操作系统中有一个记录空闲内存地址的链表。</strong>当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。注意这块内存不是全分配给程序，而是将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。<br>调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。</p><p><strong>实际申请空间的大小 = 管理空间 + 用户空间。</strong>malloc() 申请的空间实际是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。用来记录管理信息的实际上是一个结构体。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> &#123;</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">int</span> is_available;    <span class="comment">// 这是一个标记</span></span><br><span class="line">    <span class="keyword">int</span> size;            <span class="comment">// 实际空间的大小</span></span><br><span class="line">    ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">long</span> numbytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *current_location;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> *<span class="title">current_location_mcb</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *memory_location;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 实际申请空间的大小 = 管理结构体大小 + 参数的大小</span></span><br><span class="line">    numbytes = numbytes + <span class="keyword">sizeof</span>(struct mem_control_block);</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">while</span>(current_location != last_valid_address)</span><br><span class="line">    &#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="comment">// 寻找合适的内存块</span></span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">return</span> memory_location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc申请成功返回的是一个指向大小为NumBytes的内存的指针，而这个指针前面还有一个mem_control_block结构体用来记录管理信息，它们的地址是连续的，所以所分配的内存比所要求的要稍大一些，额外的空间用来记录管理信息。</p><h3 id="free-原理"><a href="#free-原理" class="headerlink" title="free 原理"></a>free 原理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> *<span class="title">free</span>;</span></span><br><span class="line">    <span class="comment">// 把指向可用空间的指针倒回去，让它指向管理信息</span></span><br><span class="line">    <span class="built_in">free</span> = ptr - <span class="keyword">sizeof</span>(struct mem_control_block); </span><br><span class="line">    <span class="built_in">free</span>-&gt;is_available = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出 free() 只是把指针回退到结构体的基地址，然后把成员变量 is_available 置为1。</p><p>这告诉操作系统这块内存可用，操作系统根据 mem_control_block 的管理信息对改内存进行回收管理，它将用户释放的内存块连接到空闲链上，并在需要的时候整合内存碎片。</p>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C/C++内存的分段和分区</title>
      <link href="/2018/08/26/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
      <url>/2018/08/26/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
      <content type="html"><![CDATA[<h3 id="按段划分"><a href="#按段划分" class="headerlink" title="按段划分"></a>按段划分</h3><ul><li><p><strong>代码段（code segment/text segment）</strong><br>通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><a id="more"></a></li><li><p><strong>数据段（data segment）</strong><br>通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配，有初始化的全局变量和静态变量存放在这里。</p></li><li><p><strong>BSS段（bss segment）</strong><br>通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配，有未的全局变量和静态变量存放在这里。</p></li><li><p><strong>堆（heap）</strong><br>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上；当利用free等函数释放内存时，被释放的内存从堆中被剔除</p></li><li><p><strong>栈（stack）</strong><br>是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。</p></li></ul><hr><h3 id="按区划分"><a href="#按区划分" class="headerlink" title="按区划分"></a>按区划分</h3><ul><li><p><strong>代码区（code)</strong><br>代码区是只读的，该区域是用来存放程序的代码的，内存由系统管理。</p></li><li><p><strong>常量区（constants）</strong><br>常量在系统一运行被创建，常量区的内存是只读的，如常量字符串就放在这个区。你可以读他们，但是不可以修改他们，内存由系统管理。</p></li><li><p><strong>全局区（globals）</strong><br>定义在函数外边的全局变量和静态变量就放在这个这里，这里的变量在程序已启动就被创建，你可以自由的更改他们，所以是由系统管理的可读可写的内存。</p></li><li><p><strong>堆（heap）</strong><br>是一块动态内存，由程序员自己申请自己释放的内存空间，<strong>其内存由程序管理</strong>，当程序运行时候动态分配给变量，它可以长时间存在，所以，<strong>申请一个堆内存就必须有释放的过程，</strong>同时指向堆内存的指针不能改变，否则这个堆内存永远都得不到释放，除非程序崩溃或者运行结束导致系统回收程序所在的内存，这样就很容易造成内存泄漏（是指程序运行期间，程序结束后程序所占用的内存就释放了），它是可读可写的。</p></li><li><p><strong>栈（stack）</strong><br>在需要的时候由系统自动分配，在不需要的时候会由系统自动回收的存储区，内存由系统管理，函数中定义的变量存储在栈中，当调用函数的时候函数中定义的变量会被加到栈中，当函数离开的时候，被添加的变量会从栈中弹出，里面的内容可读可写。</p></li></ul>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim - 基本使用</title>
      <link href="/2018/08/25/vim%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/08/25/vim%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="vim-的基本使用"><a href="#vim-的基本使用" class="headerlink" title="vim 的基本使用"></a>vim 的基本使用</h2><p><strong>vim有三种模式</strong></p><ul><li><p>指令模式（查找和替换）</p></li><li><p>编辑模式（编辑文本）</p></li><li><p>常规模式（光标移动、复制、粘贴、删除）</p></li></ul><p>任何模式下使用ESC可返回常规模式<br><a id="more"></a></p><h4 id="打开文件、新建文件、保存文件"><a href="#打开文件、新建文件、保存文件" class="headerlink" title="打开文件、新建文件、保存文件"></a>打开文件、新建文件、保存文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi &lt;文件名&gt;  若文件存在则打开文件，不存在则新建并打开</span><br><span class="line">输入 <span class="string">':'</span> 进入指令模式</span><br><span class="line">输入 q (quit) 退出文件</span><br><span class="line">输入 wq (write quit) 写入修改的内容并退出</span><br><span class="line">输入 q! 强制退出不保存修改的内容</span><br></pre></td></tr></table></figure><h4 id="进入编辑模式"><a href="#进入编辑模式" class="headerlink" title="进入编辑模式"></a>进入编辑模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i(在光标前开始插入文本,一般使用i)</span><br><span class="line">a在光标后开始插入文本</span><br><span class="line">o(在当前行之下新开一行，并到行首)</span><br></pre></td></tr></table></figure><h4 id="光标快速定位"><a href="#光标快速定位" class="headerlink" title="光标快速定位"></a>光标快速定位</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngg光标移至第n行的行首（n为数字）</span><br><span class="line">1gg就跳到第一行的行首</span><br><span class="line">2gg就跳到第二行的行首</span><br><span class="line">G转至文件结尾</span><br><span class="line">注意：ngg和G是在一般模式</span><br></pre></td></tr></table></figure><h4 id="在当前行定位到某个字符"><a href="#在当前行定位到某个字符" class="headerlink" title="在当前行定位到某个字符"></a>在当前行定位到某个字符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fx搜索当前行中下一个出现字母x的地方</span><br><span class="line">注意：fx是在一般模式</span><br></pre></td></tr></table></figure><h4 id="文本复制、粘贴、删除、撤销"><a href="#文本复制、粘贴、删除、撤销" class="headerlink" title="文本复制、粘贴、删除、撤销"></a>文本复制、粘贴、删除、撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yy复制当前行(y:yank(复制))</span><br><span class="line">nyy复制当前行及其后的n-1行(n是数字)</span><br><span class="line">使用P键来粘贴(p:paste)</span><br><span class="line"></span><br><span class="line">dd 删除光标所在行(d:delete)</span><br><span class="line">ndd 删除当前行及其后的n-1行(n是数字)</span><br><span class="line"></span><br><span class="line">按u键来撤销上一步操作</span><br><span class="line">x删除光标所在位置的字符</span><br><span class="line">注意：yy/nyy/dd/ndd/x/u都是在一般模式。</span><br></pre></td></tr></table></figure><h4 id="查找内容"><a href="#查找内容" class="headerlink" title="查找内容"></a>查找内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入 <span class="string">'/'</span> 进入指令模式</span><br><span class="line">输入pattern 从光标开始处向文件尾搜索pattern</span><br><span class="line">按下n或N可继续搜索下一个或上一个pattern</span><br><span class="line">n在同一个方向重复上一次搜索命令</span><br><span class="line">N在反方向重复上一次搜索命令</span><br><span class="line">n表示next</span><br><span class="line">注意：/pattern是从光标处开始搜索的</span><br></pre></td></tr></table></figure><h4 id="替换指定内容"><a href="#替换指定内容" class="headerlink" title="替换指定内容"></a>替换指定内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入 <span class="string">':'</span> 进入指令模式</span><br><span class="line">输入%s/p1/p2/g将文件中所有的p1均用p2替换</span><br><span class="line">输入%s/p1/p2/gc替换时需要确认</span><br><span class="line"></span><br><span class="line">s: substitute替换</span><br><span class="line">g: global全局</span><br><span class="line">c: confirm确认</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello Markdown</title>
      <link href="/2018/08/25/MarkdwonTest/"/>
      <url>/2018/08/25/MarkdwonTest/</url>
      <content type="html"><![CDATA[<h2 id="Markdown-Test"><a href="#Markdown-Test" class="headerlink" title="Markdown Test"></a>Markdown Test</h2><p><strong>在Hexo写博客用的是Markdown标记语言，这篇博客用于熟悉Markdown的一些常规标记语法，包括标记标题、粗体、代码段、分节等基本语法。</strong></p><a id="more"></a><h3 id="test-cpp"><a href="#test-cpp" class="headerlink" title="test cpp"></a>test cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Markdown!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>g++ test.cpp -o test</p><h3 id="test-c"><a href="#test-c" class="headerlink" title="test c"></a>test c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello Markdown!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc test.c -o test<br><img src="http://pe4fbo1qb.bkt.clouddn.com/test.png" alt="test.png"><br><img src="http://pe4fbo1qb.bkt.clouddn.com/preview.png" alt="preview.png"></p>]]></content>
      
      
    </entry>
    
  
  
</search>
